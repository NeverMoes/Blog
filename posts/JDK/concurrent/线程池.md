

# 线程池

[toc]

## 体系结构
![](https://i.loli.net/2020/05/04/ydzXFIHVklWZK6n.png)

1. `Executor`，`ExecutorService`：线程池相关接口。
2. `ScheduledExecutorService`：定时任务相关接口。
3. `AbstractExecutorService`：抽象类。
4. `ThreadPoolExecutor`：普通线程池，即一般所说的线程池。
5. `ScheduledThreadPoolExecutor`：定时任务线程池。
6. `ForkJoinPool`：Java7 中新增的线程池，适用于任务无限多的场景。
7. `Executors`：线程池工具类，用于快速实现线程池。

### 接口一览

#### Executor

顶级接口。

```java
public interface Executor {
    // 执行无返回值任务
    void execute(Runnable command);
}
```

#### ExecutorService

主要增加了以下四类方法：

1. 关闭线程池。
2. 判断线程池是否关闭。
3. 执行任务。
4. 批量执行任务。

```java
public interface ExecutorService extends Executor {
  	/**
  	* 关闭线程池方法
  	*/
  
    // 关闭线程池，不再接受新任务，但已经提交的任务会执行完成
    void shutdown();

    // 立即关闭线程池，尝试停止正在运行的任务，未执行的任务将不再执行
    // 被迫停止及未执行的任务将以列表的形式返回
    List<Runnable> shutdownNow();

    /**
  	* 检查关闭方法
  	*/
  
    // 检查线程池是否已关闭
    boolean isShutdown();

    // 线程池关闭后所有任务是否已经完成
    // 注意：只有在shutdown()或shutdownNow()之后调用才有可能为 true
    boolean isTerminated();
    
    // 在指定时间内线程池达到终止状态了才会返回 true
    // 超时返回 false
    // 如果过程中被中断则抛出 InterruptedException
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    
    /**
  	* 线程池执行方法
  	*/
  
    // 执行有返回值的任务，任务完成时才存在返回值
    // 任务的返回值为 task.call()
    <T> Future<T> submit(Callable<T> task);

    // 同上，返回值为传入的 result
    <T> Future<T> submit(Runnable task, T result);
    
    // 同上，返回值为 null
    Future<?> submit(Runnable task);

    // 批量执行，只有当这些任务都完成了这个方法才会返回
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

    // 在指定时间内批量执行任务，未执行完成的任务将被取消
    // 这里的timeout是所有任务的总时间，不是单个任务的时间
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;
    
    // 返回任意一个已完成任务的执行结果，未执行完成的任务将被取消
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

    // 在指定时间内如果有任务已完成，则返回任意一个已完成任务的执行结果，未执行完成的任务将被取消
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

#### ScheduledExecutorService

添加延时任务执行方法。

```java
public interface ScheduledExecutorService extends ExecutorService {
    // 在指定延时后执行一次
    public ScheduledFuture<?> schedule(Runnable command,
                                       long delay, TimeUnit unit);
    public <V> ScheduledFuture<V> schedule(Callable<V> callable,
                                           long delay, TimeUnit unit);
                                           
    // 在指定延时后开始执行，并在之后以指定时间间隔重复执行（间隔不包含任务执行的时间）
    // 即间隔延时以任务开始计算
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);

    // 在指定延时后开始执行，并在之后以指定延时重复执行（间隔包含任务执行的时间）
    // 即间隔延时以任务结束计算
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit);

}
```

#### AbstractExecutorService

抽象类，运用模板方法设计模式实现了一部分方法。

主要为执行有返回值任务、批量执行任务的方法。

注意这里的 `submit` 方法将传入的任务都包装成了 `FutureTask` 来进行处理。

```java
public abstract class AbstractExecutorService implements ExecutorService {

    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }

    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        return new FutureTask<T>(callable);
    }

    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }

    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }

    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException {
        // 略...
    }

    public <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                           long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
        // 略...
    }

    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException {
        // 略...
    }

    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                         long timeout, TimeUnit unit)
        throws InterruptedException {
        // 略...
    }
```

## ThreadPoolExecutor

### 构造

线程池四个构造函数，最终都会调用到一个七个参数的构造函数上

这里涉及到线程池一个非常经典的问题。线程池的参数怎么设定。最简单直接直接的就是看官方文档里面的注释到底是怎么写的。

```java
    /**
     * Creates a new {@code ThreadPoolExecutor} with the given initial
     * parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param maximumPoolSize the maximum number of threads to allow in the
     *        pool
     * @param keepAliveTime when the number of threads is greater than
     *        the core, this is the maximum time that excess idle threads
     *        will wait for new tasks before terminating.
     * @param unit the time unit for the {@code keepAliveTime} argument
     * @param workQueue the queue to use for holding tasks before they are
     *        executed.  This queue will hold only the {@code Runnable}
     *        tasks submitted by the {@code execute} method.
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if one of the following holds:<br>
     *         {@code corePoolSize < 0}<br>
     *         {@code keepAliveTime < 0}<br>
     *         {@code maximumPoolSize <= 0}<br>
     *         {@code maximumPoolSize < corePoolSize}
     * @throws NullPointerException if {@code workQueue}
     *         or {@code threadFactory} or {@code handler} is null
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
```

1. **corePoolSize**：**核心线程数量**，无论线程池是否空闲。线程池会保持一定的核心线程数量，**除非设置了 allowCoreThreadTimeOut**。
   * allowCoreThreadTimeOut：为 true 时，**keepAliveTime 会对核心线程也生效**。
2. **maximumPoolSize**：**最大线程数量**，线程池允许创建的最大线程数量，如果超过会使用拒绝策略。
3. **keepAliveTime**，**unit**：**存活时间**，经过一定存活时间后，**非核心线程**没有接受到任务就会被销毁。
4. **workQueue**：**缓存队列**，当提交的任务数超过核心线程数大小后，再提交的任务就存放在这里。注意必须为阻塞队列。
5. **threadFactory**：**线程工厂**，用于自定义线程名称等场景。
6. **handler**：**拒绝策略**，达到最大线程数量且任务队列已满时，接收新任务时的拒绝策略。

![](https://i.loli.net/2020/05/06/yG2gXlU6IkKJo34.png)





### ScheduledThreadPoolExecutor

```java

```

### ForkJoinPool
```java

```

### Executors
```java

```


官方文档中的注释

```java

```





## 小结

`ExecutorService`中

* `void shutdown()`
* `List<Runnable> shutdownNow()`
* 

的区别

---

* `boolean isShutdown();`
* `boolean isTerminated();`
* `boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;`
* 的区别

## 参考

1. [死磕 java线程系列之线程池深入解析——体系结构](https://juejin.im/post/5da499af518825237369f4c1)

[如何设置线程池参数？](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650127132&idx=3&sn=a2c9b3f1b7a085ec413ca28759d7e22e)

[Java线程池实现原理及其在美团业务中的实践](https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651751537&idx=1&sn=c50a434302cc06797828782970da190e)

